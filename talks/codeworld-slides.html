<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>CodeWorld.info Presentation</title>

		<link rel="stylesheet" href="../reveal/css/reveal.css">
		<link rel="stylesheet" href="../reveal/css/theme/default.css" id="theme">

        <link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

                <!-- Slides are separated by three dashes (quick 'n dirty regular expression) -->
                <section data-markdown data-separator="---">
                    <script type="text/template">
                        # CodeWorld.info
                        [Josh Cough](http://joshcough.com/) / [@joshcough](http://twitter.com/joshcough)
---
## Maze Generator: interationOf
```haskell
main = interactionOf(createWorld, fst, event, drawWorld)
```
---
## World Creation
```haskell
data World = World { loc :: Point, maze :: Grid }
createWorld rs = World { loc = (0, 0), maze = buildMaze 10 10 rs }
```
---
## World Creation: Helpful Types
```haskell
type Door = (Point, Point)

type Direction = Vector

directions = [north, south, east, west]
north = (0, 1); south = ( 0, -1)
east  = (1, 0); west  = (-1,  0)

addDirToPoint :: Point -> Direction -> Point
addDirToPoint (px, py) (dx, dy) = (px + dx, py + dy)
```
---
## World Creation: More Helpful Types
```Haskell
type RandomSupply = [Number]

type Set a = [a]
addToSet :: Set a -> a -> Set a
addToSet s a = nub (a : s)
```
---
## World Creation: Grid
```haskell
data Grid = Grid {
  width   :: Number,    height :: Number,
  visited :: Set Point, doors  :: Set Door }
```
---
## Grid Operations
```haskell
addDoor :: Grid -> Door -> Grid
addDoor g d = g { doors = addToSet (doors g) d }

containsDoor :: Set Door -> Door -> Bool
containsDoor ds ((fx,fy),(tx,ty)) = any (ds, match) where
  match ((fx',fy'),(tx',ty')) =
    (fx == fx' && fy == fy' && tx == tx' && ty == ty') ||
    (fx == tx' && fy == ty' && tx == fx' && ty == fy')
```
---
## Grid Operations Continued
```haskell    
markVisitedAt :: Grid -> Point -> Grid
markVisitedAt g p = g { visited = addToSet (visited g) p }

isVisitedAt :: Grid -> Point -> Bool
isVisitedAt g p = isMember (visited g, p)
```
---
## Grid Operations Continued
```haskell
neighbors :: Grid -> Point -> Set Point
neighbors g p = filter (map (directions, addDirToPoint p), inbounds) where
  inbounds (x,y) = x >= 0 && x < width g && y >= 0 && y < height g

unvisitedNeighbors :: Grid -> Point -> Set Point
unvisitedNeighbors g p = filter (neighbors g p, (not . isVisitedAt g))
```
---
## Maze Generation
```haskell
buildMaze :: Number -> Number -> RandomSupply -> Grid
buildMaze w h randoms = buildImpl exitPoint startGrid randoms where 
  startGrid = (Grid w h [] (entranceDoor : exitDoor : []))
  exitPoint = (w - 1, h - 1)
  entranceDoor = ((-1,0), (0,0))
  exitDoor     = ((w-1,h-1), (w,h-1))  
  buildImpl :: Point -> Grid -> RandomSupply -> Grid
  buildImpl current g rs = foldl f newGrid nbors where
    newGrid = markVisitedAt g current
    (nbors, randoms') = shuffle (unvisitedNeighbors newGrid current) rs
    f gacc n = if isVisitedAt gacc n then gacc else recur where
      newG  = addDoor gacc (current, n)
      recur = buildImpl n newG randoms'
```
---
## Events
```haskell
event(w, KeyPress "Up")    = move north w
event(w, KeyPress "Down")  = move south w
event(w, KeyPress "Left")  = move west  w
event(w, KeyPress "Right") = move east  w
event(w, _) = w

move :: Direction -> World -> World
move d w@(World p@(x, y) (Grid _ _ _ ds)) = 
  w { loc = if (containsDoor ds (p, p'))  then p' else p } 
    where p' = addDirToPoint p d
```
---
## Drawing the world
```haskell
drawWorld w = scale (translate (pictures 
  [drawBall (loc w), drawMaze (maze w)], -5, -5), 1.5, 1.5) where
  drawBall (x,y) = translate (ball, x, y) 
  ball = translate (color (solidCircle 0.5, blue), 0.5, 0.5)
```
---
## Drawing the maze
```haskell
drawMaze (Grid w h _ ds) = pictures [doorsPic, allGridLines] where
  doorsPic = pictures (map (entrance : exit : ds, drawDoor))
  entrance = ((-1,0), (0,0))
  exit     = ((w-1,h-1), (w,h-1))
  allGridLines = color (pictures [horizontalLines, verticalLines], black)
  horizontalLines = pictures (map ([0..h], \y -> line [(w, y), (0, y)]))
  verticalLines   = pictures (map ([0..w], \x -> line [(x, h), (x, 0)]))
```
---
## Drawing doors
```haskell
drawDoor :: Door -> Picture
drawDoor (f, t) = color (thickLine (g f t, 0.1), white) where
 g (fx,fy) (tx,ty) 
   | fy < ty = [(fx,  fy+1), (tx+1,ty)]   -- going up
   | fy > ty = [(fx,  fy),   (tx+1,ty+1)] -- going down
   | fx < tx = [(fx+1,fy),   (tx,  ty+1)] -- going right
   | fx > tx = [(fx,  fy),   (tx+1,ty+1)] -- going left
```
---
## List shuffle
```haskell
shuffle :: [a] -> RandomSupply -> ([a], RandomSupply)
shuffle xs randoms = (as, remainingRandoms) where
  (rs, remainingRandoms) = splitAt (randoms, length xs)
  z  = [ (r,x) | r <- rs | x <- xs ]
  sortedRs = sort rs
  f r acc = (maybe (lookup (z, r), id, error "impossible")) : acc
  as = foldr f [] sortedRs
```
---
## Some Prelude functions
```haskell
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z0 xs0 = lgo z0 xs0 where
  lgo z []     =  z
  lgo z (x:xs) = lgo (f z x) xs

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr k z = go where
  go []     = z
  go (y:ys) = y `k` go ys
```

                    </script>
                </section>

            </div>
		</div>

		<script src="../reveal/lib/js/head.min.js"></script>
		<script src="../reveal/js/reveal.js"></script>

		<script>

			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal/plugin/notes/notes.js' }
				]
			});

		</script>

	</body>
</html>
