<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>CodeWorld.info Presentation</title>

		<link rel="stylesheet" href="../reveal/css/reveal.css">
		<link rel="stylesheet" href="../reveal/css/theme/default.css" id="theme">
                <link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
                <script src="../scripts/highlight.pack.js"></script>
                <script>hljs.initHighlightingOnLoad();</script>
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

                <!-- Slides are separated by three dashes (quick 'n dirty regular expression) -->
                <section data-markdown data-separator="---">
                    <script type="text/template">
# CodeWorld.info
[Josh Cough](http://joshcough.com/) / [@joshcough](http://twitter.com/joshcough)
---
## CodeWorld.info Info.
* Prelude: http://codeworld.info/doc/Prelude.html
* Repo: https://github.com/google/codeworld
* Created by Chris Smith
  * Github: https://github.com/cdsmith
  * Twitter: @cdsmithus
---
<section id="fragments">
<h2>What is CodeWorld?</h2>
<ul>
  <li class="fragment">A system for teaching kids programming and math?</li>
  <li class="fragment">A system for teaching Haskell?</li>
  <li class="fragment">Best to just see.</li>
</ul>
---
## Maze Generator: Imports
<pre><code class="haskell" data-trim>
{-# LANGUAGE NoImplicitPrelude #-}
import HaskellPrelude
import CodeWorld
import Data.Set (Set)
import qualified Data.Set as Set
</code></pre>
---
## Maze Generator: interationOf
<pre><code class="haskell" data-trim>
main = interactionOf(createWorld, fst, event, drawWorld)
</code></pre>
---
## World Creation
<pre><code class="haskell" data-trim>
data World = World { loc :: Point, maze :: Maze }

type RandomNumbers = [Number]

createWorld :: RandomNumbers -> World
createWorld rs = World { loc = (0, 0), maze = buildMaze 20 20 rs }
</code></pre>
---
## World Creation: Helpful Types
<pre><code class="haskell" data-trim>
type Door = (Point, Point)

reverseDoor :: Door -> Door
reverseDoor ((fx,fy),(tx,ty)) = ((tx,ty),(fx,fy))

type Direction = Vector

directions = Set.fromList [up, down, right, left]
up = (0, 1); down = (0, -1); right = (1, 0); left = (-1, 0)

addDirToPoint :: Point -> Direction -> Point
addDirToPoint p d = addVectors (p, d)
</code></pre>
---
## Maze
<pre><code class="haskell" data-trim>
data Maze = Maze {
  width   :: Number,    height :: Number,
  visited :: Set Point, doors  :: Set Door }

emptyMaze w h =
  Maze w h Set.empty (Set.fromList $ entranceDoor : exitDoor : [])
  where
    entranceDoor   = ((-1,0), (0,0))
    exitDoor       = ((w-1,h-1), (w,h-1))
</code></pre>
---
## Maze Operations
<pre><code class="haskell" data-trim>
addDoor :: Maze -> Door -> Maze
addDoor g d = g { doors = Set.insert d (doors g) }

containsDoor :: Set Door -> Door -> Bool
containsDoor ds d = Set.member d ds || Set.member (reverseDoor d) ds

markVisitedAt :: Maze -> Point -> Maze
markVisitedAt g p = g { visited = Set.insert p (visited g) }

isVisitedAt :: Maze -> Point -> Bool
isVisitedAt g p = Set.member p (visited g)
</code></pre>
---
## Maze Operations Continued
<pre><code class="haskell" data-trim>
neighbors :: Maze -> Point -> Set Point
neighbors g p =
  Set.filter inbounds (Set.map (addDirToPoint p) directions) where
  inbounds (x,y) = x >= 0 && x < width g && y >= 0 && y < height g

unvisitedNeighbors :: Maze -> Point -> Set Point
unvisitedNeighbors g p = Set.filter (not . isVisitedAt g) (neighbors g p)
</code></pre>
---
## Maze Generation
<pre><code class="haskell" data-trim>
buildMaze :: Number -> Number -> RandomNumbers -> Maze
buildMaze w h randoms = go (0,0) (emptyMaze w h) randoms where
  go :: Point -> Maze -> RandomNumbers -> Maze
  go current g rs = foldl f newMaze shuffledNbors where
    newMaze = markVisitedAt g current
    nbors = Set.toList $ unvisitedNeighbors newMaze current
    shuffledNbors = shuffle (nbors, head rs)
    f gacc n = if isVisitedAt gacc n then gacc else recur where
      newG  = addDoor gacc (current, n)
      recur = go n newG (tail rs)
</code></pre>
---
## Events
<pre><code class="haskell" data-trim>
event(w, KeyPress "Up")    = move up    w
event(w, KeyPress "Down")  = move down  w
event(w, KeyPress "Left")  = move left  w
event(w, KeyPress "Right") = move right w
event(w, _) = w

move :: Direction -> World -> World
move d w@(World p@(x, y) (Maze _ _ _ ds)) = 
  w { loc = if (containsDoor ds (p, p'))  then p' else p } 
    where p' = addDirToPoint p d
</code></pre>
---
## Drawing the world
<pre><code class="haskell" data-trim>
drawWorld :: World -> Picture
drawWorld w = scale (translate (pictures
  [drawBall $ loc w, drawMaze $ maze w], -10, -10), 0.98, 0.98) where
  drawBall (x,y) = translate (ball, x, y)
  ball = translate (color (solidCircle 0.5, blue), 0.5, 0.5)
</code></pre>
---
## Drawing the maze
<pre><code class="haskell" data-trim>
drawMaze (Maze w h _ ds) = pictures [doorsPic, allGridLines] where
  doorsPic = pictures [drawDoor d | d <- Set.toList ds]
  allGridLines = color (pictures [horizontalLines, verticalLines], black)
  horizontalLines = pictures [line [(w, y), (0, y)] | y <- [0..h]]
  verticalLines   = pictures [line [(x, h), (x, 0)] | x <- [0..w]]
</code></pre>
---
## Drawing doors
<pre><code class="haskell" data-trim>
drawDoor :: Door -> Picture
drawDoor (from, to) = color (thickLine (g from to, 0.1), white) where
  g (fx,fy) (tx,ty)
  | fy < ty = [(fx,  fy+1), (tx+1,ty)  ] -- going up
  | fy > ty = [(fx,  fy),   (tx+1,ty+1)] -- going down
  | fx < tx = [(fx+1,fy),   (tx,  ty+1)] -- going right
  | fx > tx = [(fx,  fy),   (tx+1,ty+1)] -- going left
</code></pre>


                    </script>
                </section>

            </div>
		</div>

		<script src="../reveal/lib/js/head.min.js"></script>
		<script src="../reveal/js/reveal.js"></script>

		<script>

			Reveal.initialize({
maxScale: 3.0,
				controls: true,
				progress: true,
				history: true,
				center: true,

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal/plugin/notes/notes.js' }
				]
			});

		</script>

	</body>
</html>
